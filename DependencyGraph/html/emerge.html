<!DOCTYPE html>
<meta charset="utf-8">

<head>
    <!-- bootstrap css -->
    <link rel="stylesheet" type="text/css" href="vendors/bootstrap/css/bootstrap.css">
    <!-- custom css -->
    <link rel="stylesheet" type="text/css" href="resources/css/custom.css" />
    <!-- dark-mode-switch css -->
    <link rel="stylesheet" href="vendors/dark-mode-switch/css/dark-mode.css">

    <!-- jquery js -->
    <script type="text/javascript" src="vendors/jquery/jquery-3.6.0.min.js"></script>
    <!-- popper js -->
    <script type="text/javascript" src="vendors/popper/popper.min.js"></script>
    <!-- bootstrap js -->
    <script type="text/javascript" src="vendors/bootstrap/js/bootstrap.min.js"></script>
    <!-- d3 js -->
    <script src="vendors/d3/d3.v7.min.js"></script>
    <!-- Hull.js -->
    <script type="text/javascript" src="vendors/hull/hull.js"></script>
    <!-- simpleheat.hs -->
    <script type="text/javascript" src="vendors/simpleheat/simpleheat.js"></script>
    <!-- exported graph representations as js -->
    <script type="text/javascript" src="resources/js/graph_representations_d3_force_graph.js"></script>

    <style>
        div.graphDiv {
            width: 100%;
        }
        
        .card-body {
            padding-top: 4px;
            padding-bottom: 12px;
        }
        
        .tooltip-inner {
            background-color: white;
            color: black;
            font-size: smaller;
            min-width: 220px;
        }
        
        .bs-tooltip-bottom {
            margin-top: 6px;
        }

        .btn {
            padding: 2px;
        }
        
        .badge {
            font-size: 8px;
        }

        #projectNameListElement {
            padding-bottom: 1px;
            padding-top: 2px;
        }

        #analysisNameListElement {
            padding-bottom: 1px;
            padding-top: 1px;
        }

        #analysisDateTimeListElement {
            padding-top: 1px;
            padding-bottom: 4px;
        }

        #graphDiv {
            position: relative;
        }
        
        #inputNodeSearchLabel,
        #selectNodesLabel,
        #resetSelectionLabel,
        #fadeUnselectedNodesLabel,
        #clusterHullLabel {
            font-size: 10px;
            margin-bottom: 2px;
            padding-top: 4px;
        }
        
        #cardMenu {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 200px;
        }
        
        #menuButtonGroup {
            padding-left: 0px;
            padding-top: 6px;
            padding-bottom: 0px;
        }
        
        #dropdown-apply-metric {
            min-width: 200px;
        }
    </style>
</head>

<body>
    <div id="graphDiv"></div>

    <div id="cardMenu" class="card">
        <h6 class="card-header align-items-center text-center">
            <span aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-bounding-box-circles" viewBox="0 0 16 16">
                    <path d="M2 1a1 1 0 1 0 0 2 1 1 0 0 0 0-2zM0 2a2 2 0 0 1 3.937-.5h8.126A2 2 0 1 1 14.5 3.937v8.126a2 2 0 1 1-2.437 2.437H3.937A2 2 0 1 1 1.5 12.063V3.937A2 2 0 0 1 0 2zm2.5 1.937v8.126c.703.18 1.256.734 1.437 1.437h8.126a2.004 2.004 0 0 1 1.437-1.437V3.937A2.004 2.004 0 0 1 12.063 2.5H3.937A2.004 2.004 0 0 1 2.5 3.937zM14 1a1 1 0 1 0 0 2 1 1 0 0 0 0-2zM2 13a1 1 0 1 0 0 2 1 1 0 0 0 0-2zm12 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2z"/>
                </svg>                
                <span>
                    <small><span id="configEmergeVersion"></span></small>
                </span>
            </span>
        </h6>

        <div class="card-body">
            <ul class="list-group list-group-flush">
                <li class="list-group-item small d-flex justify-content-between align-items-center disabled py-1">
                    <span class="custom-control custom-switch float-right"> 
                    <input type="checkbox" class="custom-control-input" id="darkSwitch">
                    <label class="custom-control-label" for="darkSwitch"><small>Dark Mode</small></label>
                </span>
                </li>

                <li id="projectNameListElement" class="list-group-item small d-flex justify-content-between align-items-center">
                    <small><span id="configProjectName">project</span></small>
                </li>

                <li id="analysisNameListElement" class="list-group-item small d-flex justify-content-between align-items-center">
                    <small><span id="analysisName"></span></small>
                </li>

                <li id="analysisDateTimeListElement" class="list-group-item small d-flex justify-content-between align-items-center">
                    <small><span id="configAnalysisDateTime">bar</span></small>
                </li>

                <li class="list-group-item small d-flex justify-content-between align-items-center disabled py-1">
                    <small>Graph properties</small>
                </li>
                <li class="list-group-item small d-flex justify-content-between align-items-center py-1">
                    <small>Nodes</small>
                    <span class="badge badge-primary badge-pill" id="numberNodes">0</span>
                </li>
                <li class="list-group-item small d-flex justify-content-between align-items-center py-1">
                    <small>Edges</small>
                    <span class="badge badge-primary badge-pill" id="numberEdges">0</span>
                </li>
                <li class="list-group-item small d-flex justify-content-between align-items-center py-1">
                    <small>Charge force</small>
                    <span class="badge badge-primary badge-pill" id="chargeForce">0</span>
                </li>
            </ul>

            <div id="menuButtonGroup" class="btn-group-vertical col-sm-2">
                <div class="btn-group">
                    <button type="button" class="btn btn-primary btn-sm dropdown-toggle btn-with-spacing shadow-none" id="selectGraphButton" data-toggle="dropdown">
                        <span id="selectedGraph">selected graph</span>
                </button>
                    <div class="dropdown-menu" id="dropdown-graph" aria-labelledby="dropdown-graph">
                        <!-- injected by js -->
                    </div>
                </div>

                <button type="button" class="btn btn-primary btn-sm btn-with-spacing shadow-none" onclick="toggleNodeLabels();">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-info-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                        <path d="M8.93 6.588l-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588z"/>
                        <circle cx="8" cy="4.5" r="1"/>
                    </svg>
                </span>
                Toggle node labels
            </button>

                <div class="btn-group" role="group" aria-label="Basic example">
                    <button type="button" class="btn btn-primary btn-sm btn-with-spacing btn-with-spacing-right shadow-none" onclick="decreaseCurrentChargeForce();">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-minus-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M5.5 8a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1H6a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    force
                </button>
                    <button type="button" class="btn btn-primary btn-sm btn-with-spacing btn-with-spacing-left shadow-none" onclick="increaseCurrentChargeForce();">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-plus-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
                        </svg>
                    </span>
                    force
                </button>
                </div>

                <div class="btn-group" role="group" aria-label="Basic example">
                    <button type="button" class="btn btn-primary btn-sm btn-with-spacing btn-with-spacing-right shadow-none" onclick="zoomOut();">
                        <span aria-hidden="true">
                            <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-zoom-out" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                                <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
                                <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
                                <path fill-rule="evenodd" d="M3 6.5a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 0 1h-6a.5.5 0 0 1-.5-.5z"/>
                            </svg>
                        </span>
                        zoom
                    </button>

                    <button type="button" class="btn btn-primary btn-sm btn-with-spacing btn-with-spacing-left shadow-none" onclick="zoomIn();">
                    <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-zoom-in" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
                        <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
                        <path fill-rule="evenodd" d="M6.5 3a.5.5 0 0 1 .5.5V6h2.5a.5.5 0 0 1 0 1H7v2.5a.5.5 0 0 1-1 0V7H3.5a.5.5 0 0 1 0-1H6V3.5a.5.5 0 0 1 .5-.5z"/>
                    </svg>
                    </span>
                    zoom
                    </button>
                </div>

                <button type="button" class="btn btn-primary btn-sm btn-with-spacing shadow-none" onclick="translateCanvas('up')">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-up-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                        <path fill-rule="evenodd" d="M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"/>
                    </svg>
                </span>
            </button>
                <div class="btn-group" role="group" aria-label="Basic example">
                    <button type="button" class="btn btn-primary btn-sm btn-with-spacing btn-with-spacing-right shadow-none" onclick="translateCanvas('left')">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-left-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/>
                        </svg>
                    </span>
                </button>
                    <button type="button" class="btn btn-primary btn-sm btn-with-spacing btn-with-spacing-left  shadow-none" onclick="translateCanvas('right')">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-right-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M4 8a.5.5 0 0 0 .5.5h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 1 0-.708.708L10.293 7.5H4.5A.5.5 0 0 0 4 8z"/>
                        </svg>
                    </span>
                </button>
                </div>
                <button type="button" class="btn btn-primary btn-sm btn-with-spacing shadow-none" onclick="translateCanvas('down')">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-down-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                        <path fill-rule="evenodd" d="M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z"/>
                    </svg>
                </span>
            </button>
                <button id="buttonShowOverallStatistics" type="button" class="btn btn-primary btn-sm btn-with-spacing shadow-none" data-toggle="modal" data-target="#overallStatisticsModal">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                    </svg>
                </span>
                Overall statistics
            </button>
                <!-- Modal -->
                <div class="modal fade" id="overallStatisticsModal" tabindex="-1" role="dialog" aria-labelledby="overallStatisticsModalLabel" aria-hidden="true">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="overallStatisticsModalLabel">Overall statistics</h5>
                                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                            </button>
                            </div>
                            <div class="modal-body">
                                <table class="card-table table table-condensed">
                                    <thead class="table-borderless">
                                        <tr>
                                            <th scope="col">Statistic</th>
                                            <th scope="col">Value</th>
                                        </tr>
                                    </thead>
                                    <tbody id="tbody-statistics">
                                        <!-- injected by js -->
                                    </tbody>
                                </table>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- end modal -->
                <button type="button" id="buttonShowOverallMetrics" class="btn btn-primary btn-sm btn-with-spacing shadow-none" data-toggle="modal" data-target="#overallMetricsModal">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                    </svg>
                </span>
                Overall metrics
            </button>

                <div class="btn-group">
                    <button type="button" class="btn btn-primary btn-sm dropdown-toggle btn-with-spacing" data-toggle="dropdown"><span></span> <span class="caret"></span>Apply metrics</button>
                    <ul id="dropdown-apply-metric" class="dropdown-menu">
                        <!-- injected by js -->
                    </ul>
                </div>

                <!-- heatmap -->

                <div style="width: 100%; padding-top: 4px; padding-bottom: 0px;"></div>
                <li class="list-group-item small d-flex align-items-center py-1 disabled" style="border: 0px; margin-bottom: 0px; padding-left: 0px;">
                    <small>Heatmap settings </small>
                </li>
                
                <li class="list-group-item small d-flex align-items-center" style="padding: 0px; border: 0px; margin: 0px;">
                    <div class="form-group small" style="margin-bottom: 5px;">
                        <label style="margin-bottom: 0px;">Normal</label> <span id="badge_heat_map_normal" data-toggle="tooltip" data-placement="bottom" title="" class="badge badge-primary badge-pill"> ?</span>
                        <div>
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="switchActivateHeatmap">
                                <label class="custom-control-label" for="switchActivateHeatmap"></label>
                            </div>
                         </div>
                    </div>

                    <div>
                        <span style="padding: 5px;"></span>
                    </div>

                    <div class="form-group small" style="margin-bottom: 5px;">
                        <label style="margin-bottom: 0px;">Hybrid</label> <span id="badge_heat_map_hybrid" data-toggle="tooltip" data-placement="bottom" title="" class="badge badge-primary badge-pill"> ?</span>
                        <div>
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="switchMergeHeatmap">
                                <label class="custom-control-label" for="switchMergeHeatmap" style="margin-bottom: 0px;"></label>
                            </div>
                         </div>
                    </div>
                </li>

                <div style="width: 100%; padding-top: 4px; padding-bottom: 0px;"></div>
                <li class="list-group-item small d-flex align-items-center py-1 disabled" style="border: 0px; margin-bottom: 0px; padding-left: 0px; padding-bottom: 0px;">
                    <small>Keyboard shortcuts</small>
                </li>

                <label id="selectNodesLabel">
                    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" fill="currentColor" class="bi bi-shift" viewBox="0 0 16 16">
                        <path d="M7.27 2.047a1 1 0 0 1 1.46 0l6.345 6.77c.6.638.146 1.683-.73 1.683H11.5v3a1 1 0 0 1-1 1h-5a1 1 0 0 1-1-1v-3H1.654C.78 10.5.326 9.455.924 8.816L7.27 2.047zM14.346 9.5 8 2.731 1.654 9.5H4.5a1 1 0 0 1 1 1v3h5v-3a1 1 0 0 1 1-1h2.846z"/>
                    </svg>
                    + <b>s</b> (de)select hovered nodes</label>
                <label id="resetSelectionLabel">
                    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" fill="currentColor" class="bi bi-shift" viewBox="0 0 16 16">
                        <path d="M7.27 2.047a1 1 0 0 1 1.46 0l6.345 6.77c.6.638.146 1.683-.73 1.683H11.5v3a1 1 0 0 1-1 1h-5a1 1 0 0 1-1-1v-3H1.654C.78 10.5.326 9.455.924 8.816L7.27 2.047zM14.346 9.5 8 2.731 1.654 9.5H4.5a1 1 0 0 1 1 1v3h5v-3a1 1 0 0 1 1-1h2.846z"/>
                    </svg>
                    + <b>r</b> reset selected nodes</label>
                <label id="fadeUnselectedNodesLabel">
                    <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" fill="currentColor" class="bi bi-shift" viewBox="0 0 16 16">
                        <path d="M7.27 2.047a1 1 0 0 1 1.46 0l6.345 6.77c.6.638.146 1.683-.73 1.683H11.5v3a1 1 0 0 1-1 1h-5a1 1 0 0 1-1-1v-3H1.654C.78 10.5.326 9.455.924 8.816L7.27 2.047zM14.346 9.5 8 2.731 1.654 9.5H4.5a1 1 0 0 1 1 1v3h5v-3a1 1 0 0 1 1-1h2.846z"/>
                    </svg>
                    + <b>f</b> fade unselected nodes</label>

                    <div style="width: 100%; padding-top: 4px; padding-bottom: 0px;"></div>
                    <li class="list-group-item small d-flex align-items-center py-1 disabled" style="border: 0px; margin-bottom: 0px; padding-left: 0px;">
                        <small>Search</small>
                    </li>

                <label id="inputNodeSearchLabel" for="inputNodeSearch">0 nodes found</label>
                <div class="input-group input-group-sm">

                    <input id="inputNodeSearch" name="inputNodeSearch" type="text" class="form-control" placeholder="Search nodes" aria-label="Search" aria-describedby="search-addon" />

                    <div class="input-group-append">
                        <button id="inputNodeSearchCancel" class="btn btn-primary" type="button">
                            <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                                <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
                                <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                            </svg>
                        </button>

                    </div>
                </div>
                
                <div class="form-group small" style="width: 100%; margin-bottom: 0px;">
                    <label style="margin-bottom: 0px; padding-top: 2px;"><small>Add semantic search</small></label>
                    <div>
                        <div class="custom-control custom-switch">
                            <input type="checkbox" class="custom-control-input" id="switchAddSemanticSearch">
                            <label class="custom-control-label" for="switchAddSemanticSearch"></label>
                        </div>
                     </div>
                </div>

                <div style="width: 100%; padding-top: 4px; padding-bottom: 0px;"></div>
                <li class="list-group-item small d-flex align-items-center py-1 disabled" style="border: 0px; margin-bottom: 0px; padding-left: 0px; padding-bottom: 0px;">
                    <small>Cluster hulls</small>
                </li>

                <div id="clusterHullMenu">
                    <!-- cluster hull selection / injected by javascript -->
                </div>

            </div>

            <!-- Modal -->
            <div class="modal fade" id="overallMetricsModal" tabindex="-1" role="dialog" aria-labelledby="overallMetricsModalLabel" aria-hidden="true">
                <div class="modal-dialog" role="document">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="overallMetricsModalLabel">Overall metrics</h5>
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                        </button>
                        </div>
                        <div class="modal-body">
                            <table class="card-table table table-condensed">
                                <thead class="table-borderless">
                                    <tr>
                                        <th scope="col">Metric</th>
                                        <th scope="col">Value</th>
                                    </tr>
                                </thead>
                                <tbody id="tbody-metrics">
                                    <!-- injected by js -->
                                </tbody>
                            </table>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            </div>
            <!-- end modal -->

        </div>

        <script src="vendors/dark-mode-switch/js/dark-mode-switch.min.js"></script>

    </div>

    <script>
        // Some JS code is derived/borrowed or heavily inspired from demos/examples by the following people:
        // Mike Bostock - https://github.com/mbostock, https://bost.ocks.org/mike/
        // Tom Roth - https://bl.ocks.org/puzzler10/4438752bb93f45dc5ad5214efaa12e4a
        // Ma'moun othman/@mamounothman - https://stackoverflow.com/questions/61800343/d3-js-version-5-chart-to-pdf
        // Sam Leach/@SamuelLeach - https://gist.github.com/samuelleach/5497403
        // Pranav C Balan - https://stackoverflow.com/questions/41287778/get-all-possible-object-keys-from-a-list-of-objects-javascript-typescript
        // If I missed someone or gave wrong credit, please contact me and I'll update this.

        const activeNodeLabelColor = hexToRGB("#333333", 0.6)
        const passiveNodeLabelColor = hexToRGB("#333333", 0.2)
        const dmActiveNodeLabelColor = hexToRGB("#DDDDDD", 0.6)
        const dmPassiveNodeLabelColor = hexToRGB("#DDDDDD", 0.2)

        const activeEdgeColor = hexToRGB("#AAAAAA", 1.0);
        const passiveEdgeColor = hexToRGB("#AAAAAA", 0.2);
        const dmActiveEdgeColor = hexToRGB("#888888", 0.8)
        const dmPassiveEdgeColor = hexToRGB("#888888", 0.2)

        const toolTipMetricItemTextColor = hexToRGB("#333333", 0.7);
        const toolTipMetricItemBoxColor = hexToRGB("#333333", 1.0);
        const toolTipMetricItemBoxFillColor = hexToRGB("#f7f7f7", 1.0);

        const activeSelectionColor = '#FF0000'
        const directoryNodeColor = '#3b8cff'
        const fileNodeColor = '#d1e3ff'
        const defaultNodeColor = '#1f77b4'
        const semanticHeaderYellow = '#f5bc42'

        /**
         * * MARK: - Math constants
         */
        const TWO_TIMES_PI = 2 * Math.PI
        const ONE_THIRD_TWO_TIMES_PI = (1.0 / 3.0) * TWO_TIMES_PI

        /**
         * * MARK: - UI workarounds
         */
        // workaround from https://stackoverflow.com/questions/6985507/one-time-page-refresh-after-first-page-load to fix strange safari full screen loading problems
        let userAgent = navigator.userAgent.toLowerCase();
        if (userAgent.includes('safari')) {
            window.onload = function() {
                if (!window.location.hash) {
                    window.location = window.location + '#loaded';
                    window.location.reload();
                }
            }
        }

        // Workaround to prevent buttons that trigger modals to stay focused after dismiss (https://stackoverflow.com/questions/30322918/bootstrap-modal-restores-button-focus-on-close)
        $('body').on('hidden.bs.modal', '.modal', function() {
            $('#buttonShowOverallMetrics').blur();
            $('#buttonShowOverallStatistics').blur();
        });

        // cancel the node search by pressing the escape key
        $(document).keyup(function(e) {
            if (e.key === "Escape") {
                cancelNodeSearch()
            }
        });

        function setDarkMode(mode) {
            if (mode == true) {
                darkMode = true
                currentActiveNodeLabelColor = dmActiveNodeLabelColor
                currentPassiveNodeLabelColor = dmPassiveNodeLabelColor
                currentActiveEdgeColor = dmActiveEdgeColor
                currentPassiveEdgeColor = dmPassiveEdgeColor
                simulationUpdate()
            } else {
                darkMode = false
                currentActiveNodeLabelColor = activeNodeLabelColor
                currentPassiveNodeLabelColor = passiveNodeLabelColor
                currentActiveEdgeColor = activeEdgeColor
                currentPassiveEdgeColor = passiveEdgeColor
                simulationUpdate()
            }
        }

        /**
         * * MARK: - Metric info badge tooltip descriptions
         */
        const description_metric_sloc_in_file = '"Source lines of code (SLOC), also known as lines of code (LOC), is a software metric used to measure the size of a computer program by counting the number of lines in the text of the programs source code. SLOC is typically used to predict the amount of effort that will be required to develop a program, as well as to estimate programming productivity or maintainability once the software is produced." (Wikipedia)'
        const description_metric_number_of_methods = 'A metric representing the total number of methods found per file or entity. This is similar to a weighted methods per class (WMC) metric with a uniform complexity/weight of 1.'
        const description_metric_fan_in = '"Fan-in coupling (afferent coupling) the number of entities that depend on a given entity. It estimates in what extent the "external world" depends on the changes in a given entity" (gcc.gnu.org). This metric represents the number of dependencies FROM other files or entities.'
        const description_metric_fan_out = '"Fan-out coupling (efferent coupling) the number of entities the given entity depends upon. It estimates in what extent the given entity depends on the changes in "external world" (gcc.gnu.org). This metric represents the number of dependencies TO other files or entities.'
        const description_metric_louvain_modularity = '"The Louvain method for community detection is a method to extract communities from large networks" (Wikipedia). This metric seperates detected communities by a unique number/ node size.'
        const description_heat_map_normal = '"A heat map (or heatmap) is a data visualization technique that shows magnitude of a phenomenon as color in two dimensions" (Wikipedia). The heatmap score is based on a weighted score from the fan-out and SLOC metric. Red color indicates a warning (hotspot), that given metric scores may be to high, while decreasing into blue color.'
        const description_heat_map_hybrid = 'This is a visual (hybrid) combination of the normal graph visualization and a heatmap layer behind it'

        let heatmapMerged = false
        let heatmapActive = false

        let selectedNodesMap = {}
        let fadeUnselectedNodes = false
        let currentActiveNodeLabelColor = activeNodeLabelColor
        let currentPassiveNodeLabelColor = passiveNodeLabelColor

        let currentActiveEdgeColor = activeEdgeColor
        let currentPassiveEdgeColor = passiveEdgeColor

        const nodeStrokeStyle = "#333333";

        let darkMode = false
        let isSearching = false
        let addSemanticSearch = false
        let searchString = ""

        let searchTerms = []
        let searchResults = 0

        const radius = 7;
        const height = window.innerHeight * 2;
        const graphWidth = window.innerWidth * 2;

        const maxClusterHulls = 10
        let selectedClusterHullIds = []
        let hoveredClusterHullId = undefined

        let nodeLabelsEnabled = false

        let currentTranslation = {
            horizontal: 0,
            vertical: 0,
            lastDirection: ""
        }

        let activeMetrics
        let currentMetricKeys

        let currentGraphType
        let closeNode;

        function setDirection(direction) {
            currentTranslation.lastDirection = direction
        }

        function toggleNodeLabels() {
            nodeLabelsEnabled = !nodeLabelsEnabled
            simulationUpdate()
        }

        let zoom_handler = d3.zoom()
            .on("zoom", zoomed);

        let graphCanvas = d3.select('#graphDiv').append('canvas')
            .attr('width', graphWidth + 'px')
            .attr('height', height + 'px')
            .attr('id', 'mainCanvas')
            .node();

        let graphData = {}
        let currentGraph = ''

        let clusterMap = {}
        let clusterMetricsMap = {}

        let statistics
        let overall_metric_results

        initAppConfig()
        initHeatmapSwitches()
        initSemanticSearchSwitch()
        setInitialDarkMode()
        prepareGraphStructures()

        let context = graphCanvas.getContext('2d');

        // nice fix from https://stackoverflow.com/questions/8696631/canvas-drawings-like-lines-are-blurry to remove blurry drawing
        graphCanvas.style.height = (height / 2) + "px";
        graphCanvas.style.width = (graphWidth / 2) + "px";
        graphCanvas.getContext('2d').scale(2, 2);

        let div = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        let currentChargeForce = -500
        let currentLinkDistance = 20
        let simulation

        let transform = d3.zoomIdentity;

        // heatmap
        var heat = simpleheat('mainCanvas');
        heat.max(analysis_config['heatmap']['score']['limit']);

        // bring back d3 schemeCategory20 to live
        const schemeCategory20 = "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"

        function d3ColorExport(specifier) {
            let n = specifier.length / 6 | 0,
                colors = new Array(n),
                i = 0;
            while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
            return colors;
        }

        // important to define the domain for the ordinal scale
        const color = d3.scaleOrdinal(d3ColorExport(schemeCategory20))
            .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])

        /**
         * * MARK: - Connectivity checks 
         */
        let linkedByIndex = {};

        function isConnected(a, b) {
            return isConnectedAsTarget(a, b) || isConnectedAsSource(a, b) || a.id === b.id;
        }

        function isConnectedAsSource(a, b) {
            return linkedByIndex[`${a.id},${b.id}`];
        }

        function isConnectedAsTarget(a, b) {
            return linkedByIndex[`${b.id},${a.id}`];
        }

        function edgeBetweenSearchTerms(sourceNode, targetNode) {
            let found = false
            searchTerms.forEach(element => {
                if ( (sourceNode.id.toLowerCase().includes(element)) && (targetNode.id.toLowerCase().includes(element)) ) {
                    found = true
                }
            });
            return found
        }

        function searchTermsIncludedInNodeTags(sourceNode, targetNode) {
            let found = false
            searchTerms.forEach(element => {
                if ((stringIncludedInNodeTags(element, sourceNode) && stringIncludedInNodeTags(element, targetNode))) {
                    found = true
                }
            });
            return found
        }

        /**
         * * MARK: - Drawing on canvas
         */
         function drawEdges(context) {
            currentGraph.links.forEach(function(d) {

                context.beginPath();
                context.moveTo(d.source.x, d.source.y);
                context.lineTo(d.target.x, d.target.y);

                if (closeNode == null) { // not hovering over any node
                    if (isSearching == false) { // not searching                     
                        context.fillStyle = context.strokeStyle = nodeSourceColor = nodeColorByModularity(d.source, 0.7)

                    } else { // node search is active

                        if (addSemanticSearch == true) {

                            // the edge is between two nodes that are included in the search OR the edge is between two nodes that includes the search in one of their semantic keywords
                            if ( edgeBetweenSearchTerms(d.source, d.target) || searchTermsIncludedInNodeTags(d.source, d.target) )
                            { 
                                context.strokeStyle = currentActiveEdgeColor
                                context.fillStyle = currentActiveEdgeColor
                            } else { // the edge is not connected to a node which is included in the search
                                context.fillStyle = context.strokeStyle = currentPassiveEdgeColor
                            }

                        // normal search without semantic
                        } else {
                            // the edge is between two nodes that are included in the search
                            if (edgeBetweenSearchTerms(d.source, d.target))                            
                            { 
                                context.strokeStyle = currentActiveEdgeColor
                                context.fillStyle = currentActiveEdgeColor
                            } else { // the edge is not connected to a node which is included in the search
                                context.fillStyle = context.strokeStyle = currentPassiveEdgeColor
                            }
                        }
                    }

                } else {
                    if ((d.target.id == closeNode.id) || (d.source.id == closeNode.id)) { // there is an edge that contains our hovered node
                        context.strokeStyle = currentActiveEdgeColor
                        context.fillStyle = currentActiveEdgeColor

                    } else { // node is not included in the edge
                        context.fillStyle = context.strokeStyle = nodeColorByModularity(d.source, 0.2)
                    }   
                }

                // highlight edge if the corresponding nodes are selected
                if (d.source.id.toLowerCase() in selectedNodesMap && d.target.id.toLowerCase() in selectedNodesMap) {
                    context.strokeStyle = activeSelectionColor
                    context.fillStyle = currentActiveEdgeColor
                    context.lineWidth = 2.0;
                } else {
                    if (fadeUnselectedNodes == true || normalHeatmapIsActive() ) { // also fade away non-relevant egdes
                        context.fillStyle = context.strokeStyle = nodeColorByModularity(d.source, 0.2)
                    } 
                    context.lineWidth = 1.0;
                }

                context.stroke();

                if (closeNode != null && ((d.target.id == closeNode.id) || (d.source.id == closeNode.id))) { // draw an arrow if there is an edge that contains our hovered node
                    drawArrowhead(context, d.source, d.target, 5)

                } else if (isSearching && ( (searchTermIncludedInNode(d.target) ) && ( searchTermIncludedInNode(d.source)) )) { // draw an arrow if searching is enabled and there's an egde between searched nodes
                    drawArrowhead(context, d.source, d.target, 5)
                }
                
                else if (d.source.id.toLowerCase() in selectedNodesMap && d.target.id.toLowerCase() in selectedNodesMap) {
                    drawArrowhead(context, d.source, d.target, 5)
                }                    
                
            });
        }

        function normalSearch(node) {
            let found = false
            searchTerms.forEach(element => {
                if (node.id.toLowerCase().includes(element)) {
                    found = true
                }
            });
            return found
        }

        // the node is included in the current search OR if the search in included in one of the node's semantic tags 
        function searchTermIncludedInNode(node) {
            let found = false
                searchTerms.forEach(element => {
                    if (node.id.toLowerCase().includes(element)) {
                        found = true
                    }
                });
            return found
        } 
        
        function searchTermIncludedInNodeTags(node) {
            let found = false
            searchTerms.forEach(element => {
                if ( stringIncludedInNodeTags(element, node) ) {
                    found = true
                }
            });
            return found
        }

        function drawNodes(context) {
            currentGraph.nodes.forEach(function(d, i) {

                context.beginPath();

                //render outer circle if node was selected
                if (d.id.toLowerCase() in selectedNodesMap) {
                    context.arc(d.x, d.y, d.radius + 2.0, 0, TWO_TIMES_PI);
                    context.fillStyle = '#FF0000' //activeSelectionColor
                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                    context.fill();
                }

                context.arc(d.x, d.y, d.radius, 0, TWO_TIMES_PI, true);

                if (fadeUnselectedNodes == true || normalHeatmapIsActive() ) {
                    context.strokeStyle = nodeStrokeStyle
                    context.fillStyle = hexToRGB(nodeStrokeStyle, 0.2)
                    context.stroke();

                    if (nodeLabelsEnabled) {
                        context.fillStyle = currentPassiveNodeLabelColor;
                        drawNodeLabel(d.id, d.x + 14, d.y - 7)
                        context.fillStyle = nodeColorByModularity(d, 0.2)
                    }

                } else {

                    if (closeNode == null) { // not hovering over any node
                        if (isSearching == false) {

                            context.fillStyle = nodeColorByModularity(d)
                            context.strokeStyle = nodeStrokeStyle;
                            context.stroke();

                            if (nodeLabelsEnabled) {
                                context.fillStyle = currentActiveNodeLabelColor;
                                drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                context.fillStyle = nodeColorByModularity(d)
                            }

                        } else { // searching for nodes

                            // normal (non-semantic) search
                            if ( addSemanticSearch == false &&  normalSearch(d)) {

                                context.fillStyle = nodeColorByModularity(d)
                                context.strokeStyle = nodeStrokeStyle;
                                context.stroke();

                                context.fillStyle = currentActiveNodeLabelColor;
                                drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                context.fillStyle = nodeColorByModularity(d)

                                searchResults += 1

                            } else if ( addSemanticSearch == true && (searchTermIncludedInNode(d) || searchTermIncludedInNodeTags(d)) )
                                // add semantic search
                                // the node is included in the current search OR if the search in included in one of the node's semantic tags 
                                // draw a highlight circle behind the found node due to semantic search
                                {
                                if ( searchTermIncludedInNodeTags(d) )
                                {
                                    context.fillStyle = currentActiveNodeLabelColor;
                                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                    
                                    drawNodeHighlight(d, nodeColorByModularity(d, 1.0))
                                    context.strokeStyle = nodeStrokeStyle;
                                    context.stroke();

                                    drawNodeHighlight(d, semanticHeaderYellow, 2)
                                    context.strokeStyle = nodeStrokeStyle;
                                    context.stroke();

                                    searchResults += 1
                                    
                                } else {

                                    context.fillStyle = nodeColorByModularity(d)
                                    context.strokeStyle = nodeStrokeStyle;
                                    context.stroke();

                                    context.fillStyle = currentActiveNodeLabelColor;
                                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                    context.fillStyle = nodeColorByModularity(d)

                                    searchResults += 1
                                }

                            } else {
                                context.fillStyle = nodeColorByModularity(d, 0.2)
                                context.strokeStyle = hexToRGB(nodeStrokeStyle, 0.2)
                                context.stroke();

                                if (nodeLabelsEnabled) {
                                    context.fillStyle = currentPassiveNodeLabelColor;
                                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                    context.fillStyle = nodeColorByModularity(d, 0.2)
                                }
                            }
                        }

                    } else { // hovering over a node
                        if (isConnected(d, closeNode)) { // node is connected to hovered node
                            context.fillStyle = nodeColorByModularity(d)
                            context.strokeStyle = nodeStrokeStyle;
                            context.stroke();

                            // show/highlight node label of every connected node from the hovered node
                            context.fillStyle = currentActiveNodeLabelColor;
                            drawNodeLabel(d.id, d.x + 14, d.y - 7)
                            context.fillStyle = nodeColorByModularity(d)

                        } else { // node is not connected

                            if (d.id.toLowerCase() in selectedNodesMap) {
                                context.strokeStyle = nodeStrokeStyle
                                context.fillStyle = nodeColorByModularity(d)
                                context.stroke();
                            } else { 
                                context.strokeStyle = hexToRGB(nodeStrokeStyle, 0.2)
                                context.fillStyle = nodeColorByModularity(d, 0.2)
                                context.stroke();
                            }

                            if (nodeLabelsEnabled) {
                                context.fillStyle = currentPassiveNodeLabelColor;
                                drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                context.fillStyle = nodeColorByModularity(d, 0.2)
                            }
                        }
                    }

                } // else not fade away unselected nodes

                context.fill();

                if (i == currentGraph.nodes.length - 1) { // dont call this to often due to performance

                    if (closeNode) {
                        context.beginPath();
                        drawNode(closeNode)

                        if (closeNode.id.toLowerCase() in selectedNodesMap) {
                            context.fillStyle = activeSelectionColor
                        } else {
                            context.fillStyle = nodeColorByModularity(closeNode)
                        }
                        
                        context.fill();
                        context.strokeStyle = "#000000";
                        context.lineWidth = 1.0;
                        context.stroke();

                        drawNodeToolTip(closeNode.id, closeNode.x + 14, closeNode.y - 7, closeNode.metrics)
                    }
                }
            });
        }

        /**
         * * MARK: - Drawing a heatmap
         */

         function calculateHeatmapScore(node) {
            let score = analysis_config['heatmap']['score']['base']
            let slocScore = 0
            let fanoutScore = 0

            if (analysis_config['heatmap']['metrics']['active']['sloc'] == true) {
                // add weighted sloc metric if present
                if ('metric_sloc_in_entity' in node) {
                    slocScore = node.metric_sloc_in_entity * analysis_config['heatmap']['metrics']['weights']['sloc']
                }
                if ('metric_sloc_in_file' in node) {
                    slocScore = node.metric_sloc_in_file * analysis_config['heatmap']['metrics']['weights']['sloc']
                }
            }

            if (analysis_config['heatmap']['metrics']['active']['fan_out'] == true) {
                // add weighted fan-out metric is present
                if ('metric_fan_out_dependency_graph' in node) {
                    fanoutScore = node.metric_fan_out_dependency_graph * analysis_config['heatmap']['metrics']['weights']['fan_out']
                }
                if ('metric_fan_out_inheritance_graph' in node) {
                    fanoutScore = node.metric_fan_out_inheritance_graph * analysis_config['heatmap']['metrics']['weights']['fan_out']
                }
                if ('metric_fan_out_complete_graph' in node) {
                    fanoutScore = node.metric_fan_out_complete_graph * analysis_config['heatmap']['metrics']['weights']['fan_out']
                }
            }

            // limit the total score to the heatmap limit parameter, since the rendering seems to be buggy if this is exceeded
            let totalScore = score + slocScore + fanoutScore
            if (totalScore > analysis_config['heatmap']['score']['limit']) {
                totalScore = analysis_config['heatmap']['score']['limit']
            }

            return totalScore
        }

        function drawHeatMap(context) {
            heat.clear();
            currentGraph.nodes.forEach(function(node, i) {
                heat.add([node.x, node.y, calculateHeatmapScore(node)])
            })

            heat.draw()
            
            // reset alpha from heatmap rendering
            context.globalAlpha = 1;  
        }


        function drawLink(d) {
            context.moveTo(d.source.x, d.source.y);
            context.lineTo(d.target.x, d.target.y);
        }

        function drawNode(d) {
            context.arc(d.x, d.y, d.radius, 0, TWO_TIMES_PI);
        }

        function drawNodeHighlight(node, color, radiusOffset) {
            context.arc(node.x, node.y, node.radius + radiusOffset, 0, TWO_TIMES_PI);
            context.fillStyle = color
            context.strokeStyle = color;
            context.stroke();
            context.fill();
        }

        function drawNodeLabel(text, xPos, yPos) {
            const fontSize = 8
            context.font = fontSize + 'px Helvetica';
            context.fillText(text, xPos, yPos);
        }

        function stringIncludedInNodeTags(string, node) {
            let propertyNames = Object.getOwnPropertyNames(node.metrics)
            let searchedTag = 'metric_tag_' + string
            let found = false

            let tagProperties = propertyNames.filter(function(property) {
                return property.startsWith('metric_tag_')
            })

            tagProperties.forEach(function(propertyName) {
                if (propertyName.toLowerCase().includes(string.toLowerCase())) {
                    found = true
                }
            })
       
            return found
        }

        function drawNodeToolTip(text, xPos, yPos, nodeMetrics) {
            const fontSize = 14
            context.font = fontSize + 'px Helvetica';

            // determine the maximum label width
            let maxLineWidth = 0
            for (metricKey in nodeMetrics) {
                const val = nodeMetrics[metricKey]
                let human_readable_metric_name = metricKey.replace('metric_', '').replace(/_/gi, " ")
                const w = context.measureText(human_readable_metric_name + ": " + val).width;
                if (maxLineWidth < w) {
                    maxLineWidth = w
                }
            }

            // check if actually the title line width if bigger than any metric label line width?
            const nodeTitleLineWidth = context.measureText(text).width
            if (nodeTitleLineWidth > maxLineWidth)
                maxLineWidth = nodeTitleLineWidth

            // draw the header/title of the toolip    
            let lineHeight = fontSize * 1.286;
            context.fillStyle = hexToRGB("#0069d9", 1.0);
            context.fillRect(xPos - 6, (yPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4);
            context.strokeStyle = hexToRGB("#333333", 1.0);
            context.strokeRect(xPos - 6, (yPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4)

            context.fillStyle = hexToRGB("#FFFFFF", 0.8);
            context.fillText(text, xPos, yPos);

            // now draw the second tooltip box with all metric labels
            let metricItem = 1
            const metricFontSize = 14
            const metricLineHeight = (metricFontSize * 1.286);
            let yPosOffset = yPos + 10
            let newYPos = 0
            let renderWithTags = false

            context.font = metricFontSize + 'px Helvetica';

            for (metricKey in nodeMetrics) {
                
                // do not include any tag/tfidf metric in the primary metric section
                if (metricKey.includes('metric_tag')) {
                    renderWithTags = true
                    continue
                }

                let val = nodeMetrics[metricKey]
                let human_readable_metric_name = metricKey.replace('metric_', '').replace(/_/gi, " ")
                let metricItemText = human_readable_metric_name + ": " + val

                newYPos = yPosOffset + (metricLineHeight * metricItem)

                // Interesting bug: on Safari it seems to cause random lags if you do fillStyle/fillRect BEFORE strokeStyle/strokeRect
                context.strokeStyle = toolTipMetricItemBoxColor
                context.strokeRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight)

                context.fillStyle = toolTipMetricItemBoxFillColor
                context.fillRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight);

                context.fillStyle = toolTipMetricItemTextColor;
                context.fillText(metricItemText, xPos, newYPos - 4);

                metricItem = metricItem + 1
            }

            // render tag/tfidf metric section
            if (renderWithTags) {
                let metricItem = 1
                newYPos += 20
                
                // draw the header/title of the toolip    
                context.fillStyle = hexToRGB("#f5bc42", 1.0);
                context.fillRect(xPos - 6, (newYPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4);
                context.strokeStyle = hexToRGB("#333333", 1.0);
                context.strokeRect(xPos - 6, (newYPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4)
                context.fillStyle = hexToRGB("#333333", 0.8);
                context.fillText('Semantic keywords', xPos, newYPos);

                let yTagPosOffset = newYPos + 10

                // render tag/tfidf metrics
                for (metricKey in nodeMetrics) {
                    
                    // do not include any tag/tfidf metric in the primary metric section
                    if (!metricKey.includes('metric_tag')) {
                        continue
                    }

                    let val = nodeMetrics[metricKey]
                    let human_readable_metric_name = metricKey.replace('metric_tag', '').replace(/_/gi, "")
                    let metricItemText = human_readable_metric_name // + ": " + val

                    newYPos = yTagPosOffset + (metricLineHeight * metricItem)

                    // Interesting bug: on Safari it seems to cause random lags if you do fillStyle/fillRect BEFORE strokeStyle/strokeRect
                    context.strokeStyle = toolTipMetricItemBoxColor
                    context.strokeRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight)

                    context.fillStyle = toolTipMetricItemBoxFillColor
                    context.fillRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight);

                    context.fillStyle = toolTipMetricItemTextColor;
                    context.fillText(metricItemText, xPos, newYPos - 4);

                    metricItem = metricItem + 1
                }
            }
        }

        // borrowed from Scott Johnson / https://gist.github.com/jwir3/d797037d2e1bf78a9b04838d73436197 with minor adjustments
        function drawArrowhead(context, from, to, radius) {
            const x_center = 0.5 * (from.x + to.x)
            const y_center = 0.5 * (from.y + to.y)

            let angle;
            let x;
            let y;

            context.beginPath();

            angle = Math.atan2(to.y - from.y, to.x - from.x)
            x = radius * Math.cos(angle) + x_center;
            y = radius * Math.sin(angle) + y_center;

            context.moveTo(x, y);

            angle += ONE_THIRD_TWO_TIMES_PI
            x = radius * Math.cos(angle) + x_center;
            y = radius * Math.sin(angle) + y_center;

            context.lineTo(x, y);

            angle += ONE_THIRD_TWO_TIMES_PI
            x = radius * Math.cos(angle) + x_center;
            y = radius * Math.sin(angle) + y_center;

            context.lineTo(x, y);
            context.closePath();
            context.fill();
        }

        function nodeColorByModularity(node, alpha = 1.0) {
            if (currentGraphType.includes('file_result') || currentGraphType.includes('filesystem')) {
                if ('metric_file_result_dependency_graph_louvain_modularity_in_file' in node) {
                    return hexToRGB(color(node.metric_file_result_dependency_graph_louvain_modularity_in_file), alpha)
                } else if ('directory' in node) {
                    if (node.directory == true) {
                        return hexToRGB(directoryNodeColor)
                    }
                }
            } else {
                if (currentGraphType.includes('entity_result_dependency_graph')) {
                    if ('metric_entity_result_dependency_graph_louvain_modularity_in_entity' in node) {
                        return hexToRGB(color(node.metric_entity_result_dependency_graph_louvain_modularity_in_entity), alpha)
                    }
                }
                if (currentGraphType.includes('entity_result_inheritance_graph')) {
                    if ('metric_entity_result_inheritance_graph_louvain_modularity_in_entity' in node) {
                        return hexToRGB(color(node.metric_entity_result_inheritance_graph_louvain_modularity_in_entity), alpha)
                    }
                }
                
                if (currentGraphType.includes('entity_result_complete_graph')) {
                    if ('metric_entity_result_complete_graph_louvain_modularity_in_entity' in node) {
                        return hexToRGB(color(node.metric_entity_result_complete_graph_louvain_modularity_in_entity), alpha)
                    }
                }
            }

            return hexToRGB(defaultNodeColor) 
        }

        function setInitialDarkMode() {
            if (document.body.getAttribute("data-theme") == "dark") {
                currentActiveNodeLabelColor = dmActiveNodeLabelColor
                currentPassiveNodeLabelColor = dmPassiveNodeLabelColor
                currentActiveEdgeColor = dmActiveEdgeColor
                currentPassiveEdgeColor = dmPassiveEdgeColor
                darkMode = true
            } else {
                currentActiveNodeLabelColor = activeNodeLabelColor
                currentPassiveNodeLabelColor = passiveNodeLabelColor
                currentActiveEdgeColor = activeEdgeColor
                currentPassiveEdgeColor = passiveEdgeColor
                darkMode = false
            }
        }

        /**
         * * MARK: - Rendering concave hulls of clusters.
         */
        function setupGraphClustersById() {
            clusterMap = {}
            currentGraph.nodes.forEach(function(node, i) {
                let nodeClusterId = 0

                if (node.hasOwnProperty('metric_file_result_dependency_graph_louvain_modularity_in_file')) {
                    nodeClusterId = node.metric_file_result_dependency_graph_louvain_modularity_in_file
                } else if (node.hasOwnProperty('metric_entity_result_dependency_graph_louvain_modularity_in_entity')) {
                    nodeClusterId = node.metric_entity_result_dependency_graph_louvain_modularity_in_entity
                } else if (node.hasOwnProperty('metric_entity_result_inheritance_graph_louvain_modularity_in_entity')) {
                    nodeClusterId = node.metric_entity_result_inheritance_graph_louvain_modularity_in_entity
                } else if (node.hasOwnProperty('metric_entity_result_complete_graph_louvain_modularity_in_entity')) {
                    nodeClusterId = node.metric_entity_result_complete_graph_louvain_modularity_in_entity
                }

                nodeClusterId = nodeClusterId.toString()

                if (nodeClusterId in clusterMap) {
                    clusterMap[nodeClusterId].push(node)
                } else {
                    clusterMap[nodeClusterId] = []
                    clusterMap[nodeClusterId].push(node)
                }
            })

            // console.log(clusterMap)
        }

        function onMouseOverHullMenuNode(clusterId) {
            if (!selectedClusterHullIds.includes(clusterId)) {
                addHighlightToSVGCircle(clusterId)
            }
            hoveredClusterHullId = clusterId
            simulationUpdate()
        }

        function onMouseOutHullMenuNode(clusterId) {
            if (!selectedClusterHullIds.includes(clusterId)) {
                removeHighlightFromSVGCircle(clusterId)
            }
            hoveredClusterHullId = undefined
            simulationUpdate()
        }

        function addHighlightToSVGCircle(clusterId) {
            let hullNodeSVG = $("#clusterHullNodeSVGCircle-" + clusterId)
            hullNodeSVG.attr('stroke', 'yellow')
            hullNodeSVG.attr('stroke-width', '2')
        }

        function removeHighlightFromSVGCircle(clusterId) {
            let hullNodeSVG = $("#clusterHullNodeSVGCircle-" + clusterId)
            hullNodeSVG.attr('stroke', 'black')
            hullNodeSVG.attr('stroke-width', '1')
        }

        function onClickHullMenuNode(clusterId) {
            if (selectedClusterHullIds.includes(clusterId)) {
                removeItemAll(selectedClusterHullIds, clusterId)
                removeHighlightFromSVGCircle(clusterId)
            } else {
                selectedClusterHullIds.push(clusterId)
                addHighlightToSVGCircle(clusterId)
            }
            // console.log(selectedClusterHullIds)
            simulationUpdate()
        }

        function createClusterHullMenu() {
            // check if there is at least one cluster
            if ("0" in clusterMap) {
                // build menu
                let clusterMenuHtml = "<label id=\"clusterHullLabel\" for=\"clusterHullContainer\">Hover/select cluster hulls</label> \
                                        <div id=\"clusterHullContainer\" class=\"container\"> \
                                        <div class=\"row\">"

                // insert SVG circles
                let iteration = 0
                Object.keys(clusterMap).forEach(function(key) {

                    if (iteration < maxClusterHulls) {
                        let firstNode = clusterMap[key][0]
                        let color = nodeColorByModularity(firstNode)

                        let svgElement = "<svg onmouseover=\"onMouseOverHullMenuNode(" + key + ")\" onmouseout=\"onMouseOutHullMenuNode(" + key + ")\" onclick=\"onClickHullMenuNode(" + key + ")\" height=\"16px\" width=\"16px\" viewBox=\"0 0 18 18\"><circle id=\"clusterHullNodeSVGCircle-" + key + "\" cx=\"5\" cy=\"10\" r=\"4\" \
                                stroke=\"black\" stroke-width=\"1\" fill=\""
                        svgElement += color
                        svgElement += "\" /></svg>"
                        clusterMenuHtml += svgElement
                    }
                    iteration += 1
                });

                // finish menu and append to div
                clusterMenuHtml += "</div></div>"
                d3.select("#clusterHullMenu").html(clusterMenuHtml)

                // add tooltips to cluster hull nodes
                iteration = 0
                Object.keys(clusterMap).forEach(function(clusterId) {
                    if (iteration < maxClusterHulls) {
                        let clusterToolTipDescription = "<u>Cluster metrics</u><br>"
                        let clusterMetrics = clusterMetricsMap[clusterId]

                        // TODO: check why clusterMetrics can be undefined
                        if (clusterMetrics !== undefined) {
                            // add all cluster metrics that we can find
                            Object.keys(clusterMetrics).forEach(function(clusterMetric) {
                                let metricPrettyName = clusterMetric.replace(/_/gi, " ").replace(/metric/gi, "")
                                clusterToolTipDescription += metricPrettyName + ": " + "<b>" + clusterMetrics[clusterMetric] + "</b>" + "<br>"
                            })

                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).attr('title', clusterToolTipDescription)
                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).attr('data-html', 'true')
                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).attr('data-placement', 'bottom')
                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).tooltip();
                        }
                    }
                })
            }
        }

        function getPointArrayForClusterId(id) {
            let pointArray = []
            let clusterId = id.toString()

            if (clusterId in clusterMap) {
                clusterMap[clusterId].forEach(function(node, i) {
                    pointArray.push([node.x, node.y])
                })
            }
            return pointArray
        }

        // calculate hull
        function getHullFromPointArray(pointArray) {
            let hullArray = hull(pointArray, 60)
            return hullArray
        }

        /**
         * * MARK: - Translations on canvas
         */
        function translateCanvas(direction) {
            switch (direction) {
                case 'left':
                    transform.x += 100
                    simulationUpdate()
                    break;

                case 'down':
                    transform.y -= 100
                    simulationUpdate()
                    break;

                case 'right':
                    transform.x -= 100
                    simulationUpdate()
                    break;

                case 'up':
                    transform.y += 100
                    simulationUpdate()
                    break;
            }
        }

        /**
         * * MARK: - Zooming and scaling on canvas
         */
        function zoomed(event) {
            transform = event.transform;
            simulationUpdate();
        }

        function zoomIn() {
            d3.select(graphCanvas)
                .call(zoom_handler.scaleBy, 2)
                .call(d3.zoom().scaleExtent([1 / 10, 8]).on("zoom", zoomed))
            simulationUpdate()
        }

        function zoomOut() {
            d3.select(graphCanvas)
                .call(zoom_handler.scaleBy, 0.5)
                .call(d3.zoom().scaleExtent([1 / 10, 8]).on("zoom", zoomed))
            simulationUpdate()
        }

        startWithGraph(currentGraphType)
        zoomOut() // initialliy zoom out a bit

        /**
         * * MARK: - Called on startup an d every time you change a graph
         */
        function startWithGraph(graphType, chargeForce = currentChargeForce, linkDistance = currentLinkDistance) {

            activeMetrics = []
            currentMetricKeys = []

            currentGraphType = graphType

            currentLinkDistance = linkDistance
            currentChargeForce = chargeForce
            currentLinkDistance = linkDistance

            resetSimulationData()

            currentGraph = JSON.parse(JSON.stringify(graphData[graphType]['graph']))
            statistics = graphData[graphType]['statistics']
            overall_metric_results = graphData[graphType]['overall_metric_results']
            clusterMetricsMap = graphData[graphType]['cluster_metrics_map']

            createStatistics();
            createOverallMetricResults();

            currentGraph.nodes.forEach(function(d, i) {
                d.radius = radius
                d.metrics = {}

                for (let key in d) {
                    if (key.includes('metric_')) {
                        d.metrics[key] = d[key]
                        if (!currentMetricKeys.includes(key)) {
                            // do not include tag/tfidf metrics in the 'apply metrics' dropDown menu
                            if (!key.includes('metric_tag')) {
                                currentMetricKeys.push(key)
                            }                            
                        }
                    }
                }
            });

            setupGraphClustersById();
            createClusterHullMenu();
            createMetricsMenuEntries();
            addToolTipsToMetricEntries();
            addToolTipsToHeatMap();
            enableSearchInput();
            enableNodeSelection();

            currentGraph.links.forEach((d) => {
                linkedByIndex[`${d.source},${d.target}`] = true;
            });

            simulation = d3.forceSimulation()
                .force("center", d3.forceCenter(graphWidth / 4, height / 4))
                .force("x", d3.forceX(graphWidth / 2).strength(0.1))
                .force("y", d3.forceY(height / 2).strength(0.1))
                .force("charge", d3.forceManyBody().strength(currentChargeForce))
                .force("link", d3.forceLink()
                    .strength(1)
                    .distance(currentLinkDistance)
                    .id(function(d) {
                        return d.id;
                    }))
                .alphaTarget(0)
                .alphaDecay(0.05)

            addGraphTypeSelectionToMenu()
            setGraphProperties()

            d3.select(graphCanvas)
                .call(d3.drag().subject(dragsubject).on("start", dragstarted).on("drag", dragged).on("end", dragended))
                .call(d3.zoom().scaleExtent([1 / 10, 8]).on("zoom", zoomed))

            function dragsubject(event) {

                let i,
                    x = transform.invertX(event.x),
                    y = transform.invertY(event.y),
                    dx,
                    dy;

                for (i = currentGraph.nodes.length - 1; i >= 0; --i) {
                    node = currentGraph.nodes[i];
                    dx = x - node.x;
                    dy = y - node.y;

                    if (dx * dx + dy * dy < radius * radius) {

                        node.x = transform.applyX(node.x);
                        node.y = transform.applyY(node.y);

                        return node;
                    }
                }
            }

            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = transform.invertX(event.x);
                event.subject.fy = transform.invertY(event.y);
            }

            function dragged(event) {
                event.subject.fx = transform.invertX(event.x);
                event.subject.fy = transform.invertY(event.y);
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
            
            d3.select("canvas").on("mousemove", (event) => {
                let p = d3.pointer(event);
                let invX = transform.invertX(p[0])
                let invY = transform.invertY(p[1])

                let foundNode = simulation.find(transform.invertX(p[0]), transform.invertY(p[1]));

                // check within a close area if hovered point is nearby of foundNode
                if ((Math.abs(foundNode.x - invX) < radius) && (Math.abs(foundNode.y - invY) < radius)) {
                    closeNode = simulation.find(transform.invertX(p[0]), transform.invertY(p[1]));
                } else {
                    closeNode = null
                }

                simulationUpdate();
            })

            simulation.nodes(currentGraph.nodes)
                .on("tick", simulationUpdate);

            simulation.force("link")
                .links(currentGraph.links);
        }

        // Based on https://bl.ocks.org/jodyphelan/5dc989637045a0f48418101423378fbd
        function simulationUpdate() {

            context.save();

            context.clearRect(0, 0, graphWidth, height);
            context.translate(transform.x, transform.y);
            context.scale(transform.k, transform.k);

            // draw heatmap
            if (mergedHeatmapIsActive() || normalHeatmapIsActive() ) {
                drawHeatMap(context)
            }

            // this is pretty cpu hungry
            drawHulls(context)

            // draw edges
            drawEdges(context)

            // Draw nodes
            drawNodes(context)

            context.restore();
        }

        // draw a single cluster hull as a polygon 
        function drawHull(context, clusterId) {
            let pointArray = getPointArrayForClusterId(clusterId)
            let hullArray = getHullFromPointArray(pointArray)
            let firstNodeInCluster = clusterMap[clusterId][0]
            context.fillStyle = nodeColorByModularity(firstNodeInCluster, 0.2)

            context.beginPath();

            let firstPoint = hullArray[0]
            context.moveTo(firstPoint[0], firstPoint[1]);

            hullArray.forEach(function(arrayElement, i) {
                context.lineTo(arrayElement[0], arrayElement[1]);
            })

            context.closePath();
            context.fill();
        }

        // draw all required cluster hulls (selected/hovered nodes from the menu)
        function drawHulls(context) {

            // draw a hull if someone hovers ofer a hull menu cluster node 
            if (hoveredClusterHullId !== undefined) {
                drawHull(context, hoveredClusterHullId)
            }

            // draw every hull was was selected by a mouse click before 
            selectedClusterHullIds.forEach(clusterId => {
                drawHull(context, clusterId)
            })
        }

        /**
         * * MARK: - Handling of data structures
         */
        function prepareGraphStructures() {
            if (typeof file_result_dependency_graph !== 'undefined') {
                graphData['file_result_dependency_graph'] = {}
                graphData['file_result_dependency_graph']['graph'] = file_result_dependency_graph
                graphData['file_result_dependency_graph']['statistics'] = file_result_dependency_graph_statistics
                graphData['file_result_dependency_graph']['overall_metric_results'] =
                    file_result_dependency_graph_overall_metric_results
                graphData['file_result_dependency_graph']['cluster_metrics_map'] = file_result_dependency_graph_cluster_metrics_map
                currentGraphType = 'file_result_dependency_graph'
            }

            if (typeof entity_result_dependency_graph !== 'undefined') {
                graphData['entity_result_dependency_graph'] = {}
                graphData['entity_result_dependency_graph']['graph'] = entity_result_dependency_graph
                graphData['entity_result_dependency_graph']['statistics'] = entity_result_dependency_graph_statistics
                graphData['entity_result_dependency_graph']['overall_metric_results'] =
                    entity_result_dependency_graph_overall_metric_results
                graphData['entity_result_dependency_graph']['cluster_metrics_map'] = entity_result_dependency_graph_cluster_metrics_map
                currentGraphType = 'entity_result_dependency_graph'
            }

            if (typeof entity_result_inheritance_graph !== 'undefined') {
                graphData['entity_result_inheritance_graph'] = {}
                graphData['entity_result_inheritance_graph']['graph'] = entity_result_inheritance_graph
                graphData['entity_result_inheritance_graph']['statistics'] = entity_result_inheritance_graph_statistics
                graphData['entity_result_inheritance_graph']['overall_metric_results'] =
                    entity_result_inheritance_graph_overall_metric_results
                graphData['entity_result_inheritance_graph']['cluster_metrics_map'] = entity_result_inheritance_graph_cluster_metrics_map
            }

            if (typeof entity_result_complete_graph !== 'undefined') {
                graphData['entity_result_complete_graph'] = {}
                graphData['entity_result_complete_graph']['graph'] = entity_result_complete_graph
                graphData['entity_result_complete_graph']['statistics'] = entity_result_complete_graph_statistics
                graphData['entity_result_complete_graph']['overall_metric_results'] =
                    entity_result_complete_graph_overall_metric_results
                graphData['entity_result_complete_graph']['cluster_metrics_map'] = entity_result_complete_graph_cluster_metrics_map
            }

            if (typeof filesystem_graph !== 'undefined') {
                graphData['filesystem_graph'] = {}
                graphData['filesystem_graph']['graph'] = filesystem_graph
                graphData['filesystem_graph']['statistics'] = filesystem_graph_statistics
                graphData['filesystem_graph']['overall_metric_results'] = filesystem_graph_overall_metric_results
                graphData['filesystem_graph']['cluster_metrics_map'] = filesystem_graph_cluster_metrics_map
            }
        }

        function resetSimulationData() {
            if (simulation !== undefined) {
                simulation.stop()
            }

            metricKeys = nodesData = linksData = []
            simulation = undefined
        }

        // based on https://bocoup.com/blog/smoothly-animate-thousands-of-points-with-html5-canvas-and-d3 / Peter Beshai
        // basically animates the increase/decrease of the node radius based on chosen metrics
        function animateRadiusWithMetric(metricName) {

            let addedMetric = true
            if (activeMetrics.includes(metricName)) {
                removeItemAll(activeMetrics, metricName)
                addedMetric = false
            } else {
                activeMetrics.push(metricName)
                addedMetric = true
            }

            // console.log(metricName)
            const duration = 250;
            const ease = d3.easeCubic;

            timer = d3.timer((elapsed) => {
                // compute how far through the animation we are (0 to 1)
                const t = Math.min(1, ease(elapsed / duration));

                // update point positions (interpolate between source and target)
                currentGraph.nodes.forEach(node => {
                    if (metricName in node.metrics) {
                        // this resets all nodes back to the default radius
                        let newRadius = 0

                        // now interpolate for every x between f(0) and f(1): f(x) = f(0) * (1-x) + f(1) * x
                        if (addedMetric) {
                            newRadius = node.radius * (1 - t) + (node.radius + (node.metrics[metricName] * analysis_config['metrics']['radius_multiplication'][metricName] )) * t;
                            if (newRadius > node.radius) {
                                node.radius = newRadius
                            }
                        } else {
                            newRadius = node.radius * (1 - t) + (node.radius - (node.metrics[metricName] * analysis_config['metrics']['radius_multiplication'][metricName] )) * t;
                            if (newRadius > radius) {
                                node.radius = newRadius
                            } else {
                                node.radius = radius
                            }
                        }
                    }
                });

                // if this animation is over
                if (t === 1) {
                    // always make sure that node sizes return to default if no metric is active
                    if (activeMetrics.length == 0) {
                        currentGraph.nodes.forEach(node => {
                            node.radius = radius
                        })
                    }

                    // stop this timer since we are done animating.
                    timer.stop();
                }

                // update what is drawn on screen
                simulationUpdate();
            });
        }

        /**
         * * MARK: - Create/update the HTML/Bootstrap UI
         */

        function cancelNodeSearch() {
            $('#inputNodeSearch').val('')
            $('#inputNodeSearchLabel').text('Search inactive')
            searchString = ""

            searchTerms = []

            isSearching = false
            simulationUpdate()
        }

        // setup keyboard shortcut keys for node selection
        // shift + 's' key: select/unselect node
        // shift + 'r' key: reset current selection
        // shift + 'f' key: fade unselected nodes
        function enableNodeSelection() {
            let keySelectUnselect = 'S'
            let keyResetCurrentSelection = 'R'
            let keyFadeUnselectedNodes = 'F'

            d3.select('body')
                .on("keydown", function(event) { 

                    if (event.key == keySelectUnselect) {
                        if (closeNode != null) {
                            if (closeNode.id.toLowerCase() in selectedNodesMap) {
                                delete selectedNodesMap[closeNode.id.toLowerCase()]
                            } else {
                                selectedNodesMap[closeNode.id.toLowerCase()] = true
                            }
                            simulationUpdate()
                        }
                    }

                    if (event.key == keyResetCurrentSelection) {
                        selectedNodesMap = {}
                        simulationUpdate()
                    }

                    if (event.key == keyFadeUnselectedNodes) {
                        fadeUnselectedNodes = !fadeUnselectedNodes
                        if (fadeUnselectedNodes == true) {
                            $('#fadeUnselectedNodesLabel').html('<b>f fading unselected nodes</b>')
                        } else {
                            $('#fadeUnselectedNodesLabel').html('<b>f</b> fade unselected nodes')
                        }
                        simulationUpdate()
                    }
            });
        }

        function enableSearchInput() {
            $('#inputNodeSearchLabel').text('Search inactive')
            $('#inputNodeSearch').on('keyup change', function() {
                searchString = $(this).val().toLowerCase()

                searchTerms = searchString.split(" ")
                searchTerms = searchTerms.filter(Boolean);
                // console.log(searchTerms)
                 
                searchResults = 0
                if (searchString.length > 0 && searchTerms.length > 0) {
                    isSearching = true
                    simulationUpdate()
                    $('#inputNodeSearchLabel').text(searchResults + ' nodes found')

                } else {
                    isSearching = false
                    simulationUpdate()
                    $('#inputNodeSearchLabel').text('Search inactive')
                }
            })

            $('#inputNodeSearchCancel').on('click', function() {
                cancelNodeSearch()
            })
        }

        function addToolTipsToMetricEntries() {
            $('#badge_metric_sloc_in_file').attr('title', description_metric_sloc_in_file)
            $('#badge_metric_sloc_in_file').tooltip();
            $('#badge_metric_sloc_in_entity').attr('title', description_metric_sloc_in_file)
            $('#badge_metric_sloc_in_entity').tooltip();

            $('#badge_metric_number_of_methods_in_file').attr('title', description_metric_number_of_methods)
            $('#badge_metric_number_of_methods_in_file').tooltip();
            $('#badge_metric_number_of_methods_in_entity').attr('title', description_metric_number_of_methods)
            $('#badge_metric_number_of_methods_in_entity').tooltip();

            $('#badge_metric_fan_in_dependency_graph').attr('title', description_metric_fan_in)
            $('#badge_metric_fan_in_dependency_graph').tooltip();
            $('#badge_metric_fan_in_complete_graph').attr('title', description_metric_fan_in)
            $('#badge_metric_fan_in_complete_graph').tooltip();
            $('#badge_metric_fan_in_inheritance_graph').attr('title', description_metric_fan_in)
            $('#badge_metric_fan_in_inheritance_graph').tooltip();

            $('#badge_metric_fan_out_dependency_graph').attr('title', description_metric_fan_out)
            $('#badge_metric_fan_out_dependency_graph').tooltip();
            $('#badge_metric_fan_out_complete_graph').attr('title', description_metric_fan_out)
            $('#badge_metric_fan_out_complete_graph').tooltip();
            $('#badge_metric_fan_out_inheritance_graph').attr('title', description_metric_fan_out)
            $('#badge_metric_fan_out_inheritance_graph').tooltip();

            $('#badge_metric_file_result_dependency_graph_louvain_modularity_file').attr('title', description_metric_louvain_modularity)
            $('#badge_metric_file_result_dependency_graph_louvain_modularity_file').tooltip();

            $('#badge_metric_entity_result_dependency_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            $('#badge_metric_entity_result_dependency_graph_louvain_modularity_in_entity').tooltip();

            $('#badge_metric_entity_result_inheritance_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            $('#badge_metric_entity_result_inheritance_graph_louvain_modularity_in_entity').tooltip();

            $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').tooltip();

            $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').tooltip();
        }

        function addToolTipsToHeatMap() {
            $('#badge_heat_map_normal').attr('title', description_heat_map_normal)
            $('#badge_heat_map_normal').tooltip();

            $('#badge_heat_map_hybrid').attr('title', description_heat_map_hybrid)
            $('#badge_heat_map_hybrid').tooltip();
        }

        function createStatistics() {
            // create statistics table
            statistics_html = ""
            for (let key in statistics) {
                if (statistics.hasOwnProperty(key)) {
                    statistics_html += "<tr>"

                    statistics_html += "<td>"
                    statistics_html += key
                    statistics_html += "</td>"

                    statistics_html += "<td>"
                    statistics_html += statistics[key]
                    statistics_html += "</td>"

                    statistics_html += "</tr>"
                }
            }
            d3.select("#tbody-statistics").html(statistics_html)
        }

        function createOverallMetricResults() {
            // create metrics table
            metrics_html = ""
            for (let key in overall_metric_results) {
                if (overall_metric_results.hasOwnProperty(key)) {
                    metrics_html += "<tr>"

                    metrics_html += "<td>"
                    metrics_html += key
                    metrics_html += "</td>"

                    metrics_html += "<td>"

                    let valueString = String(overall_metric_results[key])
                    if (valueString.length > 30) {
                        valueString = valueString.substring(0, 32) + '...';
                    }

                    metrics_html += String(valueString)
                    metrics_html += "</td>"

                    metrics_html += "</tr>"
                }
            }
            d3.select("#tbody-metrics").html(metrics_html)
        }

        function createMetricsMenuEntries() {
            // create apply metrics menu entries
            applyMetricHtml = ""

            for (let key in currentMetricKeys) {
                applyMetricHtml += '<li> &nbsp; <input data-value="'
                applyMetricHtml += currentMetricKeys[key]
                applyMetricHtml += '" type="checkbox" onclick="animateRadiusWithMetric(\''
                applyMetricHtml += currentMetricKeys[key]
                applyMetricHtml += '\');"/>&nbsp; <span id="'
                applyMetricHtml += '" style="font-size:10px;">'

                let visibleMetricName = currentMetricKeys[key].replace(/_/gi, " ").replace(/metric/gi, "")
                
                // reformat the visible metric name if necessary
                if (visibleMetricName.includes('louvain modularity')) { visibleMetricName = 'louvain modularity' }
                
                applyMetricHtml += visibleMetricName
                applyMetricHtml += '</span> <small><span id="'
                applyMetricHtml += 'badge_' + currentMetricKeys[key]
                applyMetricHtml += '" data-toggle="tooltip" data-placement="bottom" title="" class="badge badge-primary badge-pill"> ?</span> </small> &nbsp;</li>'
            }

            d3.select("#dropdown-apply-metric").html(applyMetricHtml)
        }

        function setGraphProperties() {
            d3.select("#numberNodes").text(currentGraph.nodes.length)
            d3.select("#numberEdges").text(currentGraph.links.length)
            d3.select("#chargeForce").text(currentChargeForce)
        }

        function setAnalysisName() {
            let analysisName = analysis_config['analysis_name']
            if (analysisName.length > 24) {
                analysisName = analysisName.slice(0, 24) + '...'
            }
            d3.select("#analysisName").text(analysisName)
        }

        function addGraphTypeSelectionToMenu() {
            graphSelectHtml = ""
            for (let key in graphData) {
                graphSelectHtml += '<button class="dropdown-item btn-sm" style="font-size: 10px;" type="button" onclick="startWithGraph(\''
                graphSelectHtml += key
                graphSelectHtml += '\');">'
                graphSelectHtml += key.replace(/_/gi, " ")
                graphSelectHtml += "</button>"
            }

            d3.select("#dropdown-graph").html(graphSelectHtml)
            d3.select("#selectedGraph").text(currentGraphType.replace(/_/gi, " ").slice(0, 20) + '...')
        }

        function increaseCurrentChargeForce() {
            if (currentChargeForce < -50) {
                currentChargeForce += 50
                d3.select("#chargeForce").text(currentChargeForce)
                simulation.force("charge", d3.forceManyBody().strength(currentChargeForce))
                simulation.alpha(1).restart();
            }
        }

        function decreaseCurrentChargeForce() {
            currentChargeForce -= 50
            d3.select("#chargeForce").text(currentChargeForce)
            simulation.force("charge", d3.forceManyBody().strength(currentChargeForce))
            simulation.alpha(1).restart();
        }

        /**
         * * MARK: - heatmap
         */

        function normalHeatmapIsActive() {
            return heatmapActive
        }

        function mergedHeatmapIsActive() {
            return heatmapMerged
        }

        function initSemanticSearchSwitch() {
            $("#switchAddSemanticSearch").on('change', function() {
                addSemanticSearch = $(this).is(':checked');
                searchResults = 0
                simulationUpdate();
                $('#inputNodeSearchLabel').text(searchResults + ' nodes found')                
            })
        }

        function initAppConfig() {
            $('#configEmergeVersion').text('Emerge ' + analysis_config['emerge_version'])
            $('#configProjectName').text(analysis_config['project_name'])
            setAnalysisName()
            $('#configAnalysisDateTime').text(analysis_config['analysis_date'])
        }

        function initHeatmapSwitches() {
            $("#switchActivateHeatmap").on('change', function() {
                if ($(this).is(':checked')) {
                    heatmapActive = true
                    if ($("#switchMergeHeatmap").is(':checked')) {
                        $("#switchMergeHeatmap").prop('checked', false);
                        heatmapMerged = false
                    }
                } else {
                    heatmapActive = false
                }

                simulationUpdate();
            });

            $("#switchMergeHeatmap").on('change', function() {
                if ($(this).is(':checked')) {
                    heatmapMerged = true

                    if ($("#switchActivateHeatmap").is(':checked')) {
                        $("#switchActivateHeatmap").prop('checked', false);
                        heatmapActive = false
                    }
                } else {
                    heatmapMerged = false
                }

                simulationUpdate();
            });
        }

        /**
         * * MARK: - Helper functions
         */

        // borrowed from https://stackoverflow.com/questions/5767325/how-can-i-remove-a-specific-item-from-an-array
        function removeItemAll(arr, value) {
            let i = 0;
            while (i < arr.length) {
                if (arr[i] === value) {
                    arr.splice(i, 1);
                } else {
                    ++i;
                }
            }
            return arr;
        }

        //https://stackoverflow.com/questions/21646738/convert-hex-to-rgba
        function hexToRGB(hex, alpha) {
            let r = parseInt(hex.slice(1, 3), 16),
                g = parseInt(hex.slice(3, 5), 16),
                b = parseInt(hex.slice(5, 7), 16);

            if (alpha) {
                return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
            } else {
                return "rgb(" + r + ", " + g + ", " + b + ")";
            }
        }
    </script>

</body>